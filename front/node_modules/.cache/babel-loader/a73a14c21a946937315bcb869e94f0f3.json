{"ast":null,"code":"// src/utils.ts\nvar HOLE = -1;\nvar NAN = -2;\nvar NEGATIVE_INFINITY = -3;\nvar NEGATIVE_ZERO = -4;\nvar NULL = -5;\nvar POSITIVE_INFINITY = -6;\nvar UNDEFINED = -7;\nvar TYPE_BIGINT = \"B\";\nvar TYPE_DATE = \"D\";\nvar TYPE_ERROR = \"E\";\nvar TYPE_MAP = \"M\";\nvar TYPE_NULL_OBJECT = \"N\";\nvar TYPE_PROMISE = \"P\";\nvar TYPE_REGEXP = \"R\";\nvar TYPE_SET = \"S\";\nvar TYPE_SYMBOL = \"Y\";\nvar TYPE_URL = \"U\";\nvar TYPE_PREVIOUS_RESOLVED = \"Z\";\nvar Deferred = class {\n  promise;\n  resolve;\n  reject;\n\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n\n};\n\nfunction createLineSplittingTransform() {\n  const decoder = new TextDecoder();\n  let leftover = \"\";\n  return new TransformStream({\n    transform(chunk, controller) {\n      const str = decoder.decode(chunk, {\n        stream: true\n      });\n      const parts = (leftover + str).split(\"\\n\");\n      leftover = parts.pop() || \"\";\n\n      for (const part of parts) {\n        controller.enqueue(part);\n      }\n    },\n\n    flush(controller) {\n      if (leftover) {\n        controller.enqueue(leftover);\n      }\n    }\n\n  });\n} // src/flatten.ts\n\n\nfunction flatten(input) {\n  const {\n    indices\n  } = this;\n  const existing = indices.get(input);\n  if (existing) return [existing];\n  if (input === void 0) return UNDEFINED;\n  if (input === null) return NULL;\n  if (Number.isNaN(input)) return NAN;\n  if (input === Number.POSITIVE_INFINITY) return POSITIVE_INFINITY;\n  if (input === Number.NEGATIVE_INFINITY) return NEGATIVE_INFINITY;\n  if (input === 0 && 1 / input < 0) return NEGATIVE_ZERO;\n  const index = this.index++;\n  indices.set(input, index);\n  stringify.call(this, input, index);\n  return index;\n}\n\nfunction stringify(input, index) {\n  const {\n    deferred,\n    plugins,\n    postPlugins\n  } = this;\n  const str = this.stringified;\n  const stack = [[input, index]];\n\n  while (stack.length > 0) {\n    const [input2, index2] = stack.pop();\n\n    const partsForObj = obj => Object.keys(obj).map(k => `\"_${flatten.call(this, k)}\":${flatten.call(this, obj[k])}`).join(\",\");\n\n    let error = null;\n\n    switch (typeof input2) {\n      case \"boolean\":\n      case \"number\":\n      case \"string\":\n        str[index2] = JSON.stringify(input2);\n        break;\n\n      case \"bigint\":\n        str[index2] = `[\"${TYPE_BIGINT}\",\"${input2}\"]`;\n        break;\n\n      case \"symbol\":\n        {\n          const keyFor = Symbol.keyFor(input2);\n\n          if (!keyFor) {\n            error = new Error(\"Cannot encode symbol unless created with Symbol.for()\");\n          } else {\n            str[index2] = `[\"${TYPE_SYMBOL}\",${JSON.stringify(keyFor)}]`;\n          }\n\n          break;\n        }\n\n      case \"object\":\n        {\n          if (!input2) {\n            str[index2] = `${NULL}`;\n            break;\n          }\n\n          const isArray = Array.isArray(input2);\n          let pluginHandled = false;\n\n          if (!isArray && plugins) {\n            for (const plugin of plugins) {\n              const pluginResult = plugin(input2);\n\n              if (Array.isArray(pluginResult)) {\n                pluginHandled = true;\n                const [pluginIdentifier, ...rest] = pluginResult;\n                str[index2] = `[${JSON.stringify(pluginIdentifier)}`;\n\n                if (rest.length > 0) {\n                  str[index2] += `,${rest.map(v => flatten.call(this, v)).join(\",\")}`;\n                }\n\n                str[index2] += \"]\";\n                break;\n              }\n            }\n          }\n\n          if (!pluginHandled) {\n            let result = isArray ? \"[\" : \"{\";\n\n            if (isArray) {\n              for (let i = 0; i < input2.length; i++) result += (i ? \",\" : \"\") + (i in input2 ? flatten.call(this, input2[i]) : HOLE);\n\n              str[index2] = `${result}]`;\n            } else if (input2 instanceof Date) {\n              str[index2] = `[\"${TYPE_DATE}\",${input2.getTime()}]`;\n            } else if (input2 instanceof URL) {\n              str[index2] = `[\"${TYPE_URL}\",${JSON.stringify(input2.href)}]`;\n            } else if (input2 instanceof RegExp) {\n              str[index2] = `[\"${TYPE_REGEXP}\",${JSON.stringify(input2.source)},${JSON.stringify(input2.flags)}]`;\n            } else if (input2 instanceof Set) {\n              if (input2.size > 0) {\n                str[index2] = `[\"${TYPE_SET}\",${[...input2].map(val => flatten.call(this, val)).join(\",\")}]`;\n              } else {\n                str[index2] = `[\"${TYPE_SET}\"]`;\n              }\n            } else if (input2 instanceof Map) {\n              if (input2.size > 0) {\n                str[index2] = `[\"${TYPE_MAP}\",${[...input2].flatMap(_ref => {\n                  let [k, v] = _ref;\n                  return [flatten.call(this, k), flatten.call(this, v)];\n                }).join(\",\")}]`;\n              } else {\n                str[index2] = `[\"${TYPE_MAP}\"]`;\n              }\n            } else if (input2 instanceof Promise) {\n              str[index2] = `[\"${TYPE_PROMISE}\",${index2}]`;\n              deferred[index2] = input2;\n            } else if (input2 instanceof Error) {\n              str[index2] = `[\"${TYPE_ERROR}\",${JSON.stringify(input2.message)}`;\n\n              if (input2.name !== \"Error\") {\n                str[index2] += `,${JSON.stringify(input2.name)}`;\n              }\n\n              str[index2] += \"]\";\n            } else if (Object.getPrototypeOf(input2) === null) {\n              str[index2] = `[\"${TYPE_NULL_OBJECT}\",{${partsForObj(input2)}}]`;\n            } else if (isPlainObject(input2)) {\n              str[index2] = `{${partsForObj(input2)}}`;\n            } else {\n              error = new Error(\"Cannot encode object with prototype\");\n            }\n          }\n\n          break;\n        }\n\n      default:\n        {\n          const isArray = Array.isArray(input2);\n          let pluginHandled = false;\n\n          if (!isArray && plugins) {\n            for (const plugin of plugins) {\n              const pluginResult = plugin(input2);\n\n              if (Array.isArray(pluginResult)) {\n                pluginHandled = true;\n                const [pluginIdentifier, ...rest] = pluginResult;\n                str[index2] = `[${JSON.stringify(pluginIdentifier)}`;\n\n                if (rest.length > 0) {\n                  str[index2] += `,${rest.map(v => flatten.call(this, v)).join(\",\")}`;\n                }\n\n                str[index2] += \"]\";\n                break;\n              }\n            }\n          }\n\n          if (!pluginHandled) {\n            error = new Error(\"Cannot encode function or unexpected type\");\n          }\n        }\n    }\n\n    if (error) {\n      let pluginHandled = false;\n\n      if (postPlugins) {\n        for (const plugin of postPlugins) {\n          const pluginResult = plugin(input2);\n\n          if (Array.isArray(pluginResult)) {\n            pluginHandled = true;\n            const [pluginIdentifier, ...rest] = pluginResult;\n            str[index2] = `[${JSON.stringify(pluginIdentifier)}`;\n\n            if (rest.length > 0) {\n              str[index2] += `,${rest.map(v => flatten.call(this, v)).join(\",\")}`;\n            }\n\n            str[index2] += \"]\";\n            break;\n          }\n        }\n      }\n\n      if (!pluginHandled) {\n        throw error;\n      }\n    }\n  }\n}\n\nvar objectProtoNames = Object.getOwnPropertyNames(Object.prototype).sort().join(\"\\0\");\n\nfunction isPlainObject(thing) {\n  const proto = Object.getPrototypeOf(thing);\n  return proto === Object.prototype || proto === null || Object.getOwnPropertyNames(proto).sort().join(\"\\0\") === objectProtoNames;\n} // src/unflatten.ts\n\n\nvar globalObj = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : void 0;\n\nfunction unflatten(parsed) {\n  const {\n    hydrated,\n    values\n  } = this;\n  if (typeof parsed === \"number\") return hydrate.call(this, parsed);\n  if (!Array.isArray(parsed) || !parsed.length) throw new SyntaxError();\n  const startIndex = values.length;\n\n  for (const value of parsed) {\n    values.push(value);\n  }\n\n  hydrated.length = values.length;\n  return hydrate.call(this, startIndex);\n}\n\nfunction hydrate(index) {\n  const {\n    hydrated,\n    values,\n    deferred,\n    plugins\n  } = this;\n  let result;\n  const stack = [[index, v => {\n    result = v;\n  }]];\n  let postRun = [];\n\n  while (stack.length > 0) {\n    const [index2, set] = stack.pop();\n\n    switch (index2) {\n      case UNDEFINED:\n        set(void 0);\n        continue;\n\n      case NULL:\n        set(null);\n        continue;\n\n      case NAN:\n        set(NaN);\n        continue;\n\n      case POSITIVE_INFINITY:\n        set(Infinity);\n        continue;\n\n      case NEGATIVE_INFINITY:\n        set(-Infinity);\n        continue;\n\n      case NEGATIVE_ZERO:\n        set(-0);\n        continue;\n    }\n\n    if (hydrated[index2]) {\n      set(hydrated[index2]);\n      continue;\n    }\n\n    const value = values[index2];\n\n    if (!value || typeof value !== \"object\") {\n      hydrated[index2] = value;\n      set(value);\n      continue;\n    }\n\n    if (Array.isArray(value)) {\n      if (typeof value[0] === \"string\") {\n        const [type, b, c] = value;\n\n        switch (type) {\n          case TYPE_DATE:\n            set(hydrated[index2] = new Date(b));\n            continue;\n\n          case TYPE_URL:\n            set(hydrated[index2] = new URL(b));\n            continue;\n\n          case TYPE_BIGINT:\n            set(hydrated[index2] = BigInt(b));\n            continue;\n\n          case TYPE_REGEXP:\n            set(hydrated[index2] = new RegExp(b, c));\n            continue;\n\n          case TYPE_SYMBOL:\n            set(hydrated[index2] = Symbol.for(b));\n            continue;\n\n          case TYPE_SET:\n            const newSet = /* @__PURE__ */new Set();\n            hydrated[index2] = newSet;\n\n            for (let i = 1; i < value.length; i++) stack.push([value[i], v => {\n              newSet.add(v);\n            }]);\n\n            set(newSet);\n            continue;\n\n          case TYPE_MAP:\n            const map = /* @__PURE__ */new Map();\n            hydrated[index2] = map;\n\n            for (let i = 1; i < value.length; i += 2) {\n              const r = [];\n              stack.push([value[i + 1], v => {\n                r[1] = v;\n              }]);\n              stack.push([value[i], k => {\n                r[0] = k;\n              }]);\n              postRun.push(() => {\n                map.set(r[0], r[1]);\n              });\n            }\n\n            set(map);\n            continue;\n\n          case TYPE_NULL_OBJECT:\n            const obj = /* @__PURE__ */Object.create(null);\n            hydrated[index2] = obj;\n\n            for (const key of Object.keys(b).reverse()) {\n              const r = [];\n              stack.push([b[key], v => {\n                r[1] = v;\n              }]);\n              stack.push([Number(key.slice(1)), k => {\n                r[0] = k;\n              }]);\n              postRun.push(() => {\n                obj[r[0]] = r[1];\n              });\n            }\n\n            set(obj);\n            continue;\n\n          case TYPE_PROMISE:\n            if (hydrated[b]) {\n              set(hydrated[index2] = hydrated[b]);\n            } else {\n              const d = new Deferred();\n              deferred[b] = d;\n              set(hydrated[index2] = d.promise);\n            }\n\n            continue;\n\n          case TYPE_ERROR:\n            const [, message, errorType] = value;\n            let error = errorType && globalObj && globalObj[errorType] ? new globalObj[errorType](message) : new Error(message);\n            hydrated[index2] = error;\n            set(error);\n            continue;\n\n          case TYPE_PREVIOUS_RESOLVED:\n            set(hydrated[index2] = hydrated[b]);\n            continue;\n\n          default:\n            if (Array.isArray(plugins)) {\n              const r = [];\n              const vals = value.slice(1);\n\n              for (let i = 0; i < vals.length; i++) {\n                const v = vals[i];\n                stack.push([v, v2 => {\n                  r[i] = v2;\n                }]);\n              }\n\n              postRun.push(() => {\n                for (const plugin of plugins) {\n                  const result2 = plugin(value[0], ...r);\n\n                  if (result2) {\n                    set(hydrated[index2] = result2.value);\n                    return;\n                  }\n                }\n\n                throw new SyntaxError();\n              });\n              continue;\n            }\n\n            throw new SyntaxError();\n        }\n      } else {\n        const array = [];\n        hydrated[index2] = array;\n\n        for (let i = 0; i < value.length; i++) {\n          const n = value[i];\n\n          if (n !== HOLE) {\n            stack.push([n, v => {\n              array[i] = v;\n            }]);\n          }\n        }\n\n        set(array);\n        continue;\n      }\n    } else {\n      const object = {};\n      hydrated[index2] = object;\n\n      for (const key of Object.keys(value).reverse()) {\n        const r = [];\n        stack.push([value[key], v => {\n          r[1] = v;\n        }]);\n        stack.push([Number(key.slice(1)), k => {\n          r[0] = k;\n        }]);\n        postRun.push(() => {\n          object[r[0]] = r[1];\n        });\n      }\n\n      set(object);\n      continue;\n    }\n  }\n\n  while (postRun.length > 0) {\n    postRun.pop()();\n  }\n\n  return result;\n} // src/turbo-stream.ts\n\n\nasync function decode(readable, options) {\n  const {\n    plugins\n  } = options ?? {};\n  const done = new Deferred();\n  const reader = readable.pipeThrough(createLineSplittingTransform()).getReader();\n  const decoder = {\n    values: [],\n    hydrated: [],\n    deferred: {},\n    plugins\n  };\n  const decoded = await decodeInitial.call(decoder, reader);\n  let donePromise = done.promise;\n\n  if (decoded.done) {\n    done.resolve();\n  } else {\n    donePromise = decodeDeferred.call(decoder, reader).then(done.resolve).catch(reason => {\n      for (const deferred of Object.values(decoder.deferred)) {\n        deferred.reject(reason);\n      }\n\n      done.reject(reason);\n    });\n  }\n\n  return {\n    done: donePromise.then(() => reader.closed),\n    value: decoded.value\n  };\n}\n\nasync function decodeInitial(reader) {\n  const read = await reader.read();\n\n  if (!read.value) {\n    throw new SyntaxError();\n  }\n\n  let line;\n\n  try {\n    line = JSON.parse(read.value);\n  } catch (reason) {\n    throw new SyntaxError();\n  }\n\n  return {\n    done: read.done,\n    value: unflatten.call(this, line)\n  };\n}\n\nasync function decodeDeferred(reader) {\n  let read = await reader.read();\n\n  while (!read.done) {\n    if (!read.value) continue;\n    const line = read.value;\n\n    switch (line[0]) {\n      case TYPE_PROMISE:\n        {\n          const colonIndex = line.indexOf(\":\");\n          const deferredId = Number(line.slice(1, colonIndex));\n          const deferred = this.deferred[deferredId];\n\n          if (!deferred) {\n            throw new Error(`Deferred ID ${deferredId} not found in stream`);\n          }\n\n          const lineData = line.slice(colonIndex + 1);\n          let jsonLine;\n\n          try {\n            jsonLine = JSON.parse(lineData);\n          } catch (reason) {\n            throw new SyntaxError();\n          }\n\n          const value = unflatten.call(this, jsonLine);\n          deferred.resolve(value);\n          break;\n        }\n\n      case TYPE_ERROR:\n        {\n          const colonIndex = line.indexOf(\":\");\n          const deferredId = Number(line.slice(1, colonIndex));\n          const deferred = this.deferred[deferredId];\n\n          if (!deferred) {\n            throw new Error(`Deferred ID ${deferredId} not found in stream`);\n          }\n\n          const lineData = line.slice(colonIndex + 1);\n          let jsonLine;\n\n          try {\n            jsonLine = JSON.parse(lineData);\n          } catch (reason) {\n            throw new SyntaxError();\n          }\n\n          const value = unflatten.call(this, jsonLine);\n          deferred.reject(value);\n          break;\n        }\n\n      default:\n        throw new SyntaxError();\n    }\n\n    read = await reader.read();\n  }\n}\n\nfunction encode(input, options) {\n  const {\n    plugins,\n    postPlugins,\n    signal\n  } = options ?? {};\n  const encoder = {\n    deferred: {},\n    index: 0,\n    indices: /* @__PURE__ */new Map(),\n    stringified: [],\n    plugins,\n    postPlugins,\n    signal\n  };\n  const textEncoder = new TextEncoder();\n  let lastSentIndex = 0;\n  const readable = new ReadableStream({\n    async start(controller) {\n      const id = flatten.call(encoder, input);\n\n      if (Array.isArray(id)) {\n        throw new Error(\"This should never happen\");\n      }\n\n      if (id < 0) {\n        controller.enqueue(textEncoder.encode(`${id}\n`));\n      } else {\n        controller.enqueue(textEncoder.encode(`[${encoder.stringified.join(\",\")}]\n`));\n        lastSentIndex = encoder.stringified.length - 1;\n      }\n\n      const seenPromises = /* @__PURE__ */new WeakSet();\n\n      while (Object.keys(encoder.deferred).length > 0) {\n        for (const [deferredId, deferred] of Object.entries(encoder.deferred)) {\n          if (seenPromises.has(deferred)) continue;\n          seenPromises.add(encoder.deferred[Number(deferredId)] = raceSignal(deferred, encoder.signal).then(resolved => {\n            const id2 = flatten.call(encoder, resolved);\n\n            if (Array.isArray(id2)) {\n              controller.enqueue(textEncoder.encode(`${TYPE_PROMISE}${deferredId}:[[\"${TYPE_PREVIOUS_RESOLVED}\",${id2[0]}]]\n`));\n              encoder.index++;\n              lastSentIndex++;\n            } else if (id2 < 0) {\n              controller.enqueue(textEncoder.encode(`${TYPE_PROMISE}${deferredId}:${id2}\n`));\n            } else {\n              const values = encoder.stringified.slice(lastSentIndex + 1).join(\",\");\n              controller.enqueue(textEncoder.encode(`${TYPE_PROMISE}${deferredId}:[${values}]\n`));\n              lastSentIndex = encoder.stringified.length - 1;\n            }\n          }, reason => {\n            if (!reason || typeof reason !== \"object\" || !(reason instanceof Error)) {\n              reason = new Error(\"An unknown error occurred\");\n            }\n\n            const id2 = flatten.call(encoder, reason);\n\n            if (Array.isArray(id2)) {\n              controller.enqueue(textEncoder.encode(`${TYPE_ERROR}${deferredId}:[[\"${TYPE_PREVIOUS_RESOLVED}\",${id2[0]}]]\n`));\n              encoder.index++;\n              lastSentIndex++;\n            } else if (id2 < 0) {\n              controller.enqueue(textEncoder.encode(`${TYPE_ERROR}${deferredId}:${id2}\n`));\n            } else {\n              const values = encoder.stringified.slice(lastSentIndex + 1).join(\",\");\n              controller.enqueue(textEncoder.encode(`${TYPE_ERROR}${deferredId}:[${values}]\n`));\n              lastSentIndex = encoder.stringified.length - 1;\n            }\n          }).finally(() => {\n            delete encoder.deferred[Number(deferredId)];\n          }));\n        }\n\n        await Promise.race(Object.values(encoder.deferred));\n      }\n\n      await Promise.all(Object.values(encoder.deferred));\n      controller.close();\n    }\n\n  });\n  return readable;\n}\n\nfunction raceSignal(promise, signal) {\n  if (!signal) return promise;\n  if (signal.aborted) return Promise.reject(signal.reason || new Error(\"Signal was aborted.\"));\n  const abort = new Promise((resolve, reject) => {\n    signal.addEventListener(\"abort\", event => {\n      reject(signal.reason || new Error(\"Signal was aborted.\"));\n    });\n    promise.then(resolve).catch(reject);\n  });\n  abort.catch(() => {});\n  return Promise.race([abort, promise]);\n}\n\nexport { decode, encode };","map":{"version":3,"names":["HOLE","NAN","NEGATIVE_INFINITY","NEGATIVE_ZERO","NULL","POSITIVE_INFINITY","UNDEFINED","TYPE_BIGINT","TYPE_DATE","TYPE_ERROR","TYPE_MAP","TYPE_NULL_OBJECT","TYPE_PROMISE","TYPE_REGEXP","TYPE_SET","TYPE_SYMBOL","TYPE_URL","TYPE_PREVIOUS_RESOLVED","Deferred","promise","resolve","reject","constructor","Promise","createLineSplittingTransform","decoder","TextDecoder","leftover","TransformStream","transform","chunk","controller","str","decode","stream","parts","split","pop","part","enqueue","flush","flatten","input","indices","existing","get","Number","isNaN","index","set","stringify","call","deferred","plugins","postPlugins","stringified","stack","length","input2","index2","partsForObj","obj","Object","keys","map","k","join","error","JSON","keyFor","Symbol","Error","isArray","Array","pluginHandled","plugin","pluginResult","pluginIdentifier","rest","v","result","i","Date","getTime","URL","href","RegExp","source","flags","Set","size","val","Map","flatMap","message","name","getPrototypeOf","isPlainObject","objectProtoNames","getOwnPropertyNames","prototype","sort","thing","proto","globalObj","window","globalThis","unflatten","parsed","hydrated","values","hydrate","SyntaxError","startIndex","value","push","postRun","NaN","Infinity","type","b","c","BigInt","for","newSet","add","r","create","key","reverse","slice","d","errorType","vals","v2","result2","array","n","object","readable","options","done","reader","pipeThrough","getReader","decoded","decodeInitial","donePromise","decodeDeferred","then","catch","reason","closed","read","line","parse","colonIndex","indexOf","deferredId","lineData","jsonLine","encode","signal","encoder","textEncoder","TextEncoder","lastSentIndex","ReadableStream","start","id","seenPromises","WeakSet","entries","has","raceSignal","resolved","id2","finally","race","all","close","aborted","abort","addEventListener","event"],"sources":["/home/vagrant/node_modules/turbo-stream/dist/turbo-stream.mjs"],"sourcesContent":["// src/utils.ts\nvar HOLE = -1;\nvar NAN = -2;\nvar NEGATIVE_INFINITY = -3;\nvar NEGATIVE_ZERO = -4;\nvar NULL = -5;\nvar POSITIVE_INFINITY = -6;\nvar UNDEFINED = -7;\nvar TYPE_BIGINT = \"B\";\nvar TYPE_DATE = \"D\";\nvar TYPE_ERROR = \"E\";\nvar TYPE_MAP = \"M\";\nvar TYPE_NULL_OBJECT = \"N\";\nvar TYPE_PROMISE = \"P\";\nvar TYPE_REGEXP = \"R\";\nvar TYPE_SET = \"S\";\nvar TYPE_SYMBOL = \"Y\";\nvar TYPE_URL = \"U\";\nvar TYPE_PREVIOUS_RESOLVED = \"Z\";\nvar Deferred = class {\n  promise;\n  resolve;\n  reject;\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n};\nfunction createLineSplittingTransform() {\n  const decoder = new TextDecoder();\n  let leftover = \"\";\n  return new TransformStream({\n    transform(chunk, controller) {\n      const str = decoder.decode(chunk, { stream: true });\n      const parts = (leftover + str).split(\"\\n\");\n      leftover = parts.pop() || \"\";\n      for (const part of parts) {\n        controller.enqueue(part);\n      }\n    },\n    flush(controller) {\n      if (leftover) {\n        controller.enqueue(leftover);\n      }\n    }\n  });\n}\n\n// src/flatten.ts\nfunction flatten(input) {\n  const { indices } = this;\n  const existing = indices.get(input);\n  if (existing)\n    return [existing];\n  if (input === void 0)\n    return UNDEFINED;\n  if (input === null)\n    return NULL;\n  if (Number.isNaN(input))\n    return NAN;\n  if (input === Number.POSITIVE_INFINITY)\n    return POSITIVE_INFINITY;\n  if (input === Number.NEGATIVE_INFINITY)\n    return NEGATIVE_INFINITY;\n  if (input === 0 && 1 / input < 0)\n    return NEGATIVE_ZERO;\n  const index = this.index++;\n  indices.set(input, index);\n  stringify.call(this, input, index);\n  return index;\n}\nfunction stringify(input, index) {\n  const { deferred, plugins, postPlugins } = this;\n  const str = this.stringified;\n  const stack = [[input, index]];\n  while (stack.length > 0) {\n    const [input2, index2] = stack.pop();\n    const partsForObj = (obj) => Object.keys(obj).map((k) => `\"_${flatten.call(this, k)}\":${flatten.call(this, obj[k])}`).join(\",\");\n    let error = null;\n    switch (typeof input2) {\n      case \"boolean\":\n      case \"number\":\n      case \"string\":\n        str[index2] = JSON.stringify(input2);\n        break;\n      case \"bigint\":\n        str[index2] = `[\"${TYPE_BIGINT}\",\"${input2}\"]`;\n        break;\n      case \"symbol\": {\n        const keyFor = Symbol.keyFor(input2);\n        if (!keyFor) {\n          error = new Error(\n            \"Cannot encode symbol unless created with Symbol.for()\"\n          );\n        } else {\n          str[index2] = `[\"${TYPE_SYMBOL}\",${JSON.stringify(keyFor)}]`;\n        }\n        break;\n      }\n      case \"object\": {\n        if (!input2) {\n          str[index2] = `${NULL}`;\n          break;\n        }\n        const isArray = Array.isArray(input2);\n        let pluginHandled = false;\n        if (!isArray && plugins) {\n          for (const plugin of plugins) {\n            const pluginResult = plugin(input2);\n            if (Array.isArray(pluginResult)) {\n              pluginHandled = true;\n              const [pluginIdentifier, ...rest] = pluginResult;\n              str[index2] = `[${JSON.stringify(pluginIdentifier)}`;\n              if (rest.length > 0) {\n                str[index2] += `,${rest.map((v) => flatten.call(this, v)).join(\",\")}`;\n              }\n              str[index2] += \"]\";\n              break;\n            }\n          }\n        }\n        if (!pluginHandled) {\n          let result = isArray ? \"[\" : \"{\";\n          if (isArray) {\n            for (let i = 0; i < input2.length; i++)\n              result += (i ? \",\" : \"\") + (i in input2 ? flatten.call(this, input2[i]) : HOLE);\n            str[index2] = `${result}]`;\n          } else if (input2 instanceof Date) {\n            str[index2] = `[\"${TYPE_DATE}\",${input2.getTime()}]`;\n          } else if (input2 instanceof URL) {\n            str[index2] = `[\"${TYPE_URL}\",${JSON.stringify(input2.href)}]`;\n          } else if (input2 instanceof RegExp) {\n            str[index2] = `[\"${TYPE_REGEXP}\",${JSON.stringify(\n              input2.source\n            )},${JSON.stringify(input2.flags)}]`;\n          } else if (input2 instanceof Set) {\n            if (input2.size > 0) {\n              str[index2] = `[\"${TYPE_SET}\",${[...input2].map((val) => flatten.call(this, val)).join(\",\")}]`;\n            } else {\n              str[index2] = `[\"${TYPE_SET}\"]`;\n            }\n          } else if (input2 instanceof Map) {\n            if (input2.size > 0) {\n              str[index2] = `[\"${TYPE_MAP}\",${[...input2].flatMap(([k, v]) => [\n                flatten.call(this, k),\n                flatten.call(this, v)\n              ]).join(\",\")}]`;\n            } else {\n              str[index2] = `[\"${TYPE_MAP}\"]`;\n            }\n          } else if (input2 instanceof Promise) {\n            str[index2] = `[\"${TYPE_PROMISE}\",${index2}]`;\n            deferred[index2] = input2;\n          } else if (input2 instanceof Error) {\n            str[index2] = `[\"${TYPE_ERROR}\",${JSON.stringify(input2.message)}`;\n            if (input2.name !== \"Error\") {\n              str[index2] += `,${JSON.stringify(input2.name)}`;\n            }\n            str[index2] += \"]\";\n          } else if (Object.getPrototypeOf(input2) === null) {\n            str[index2] = `[\"${TYPE_NULL_OBJECT}\",{${partsForObj(input2)}}]`;\n          } else if (isPlainObject(input2)) {\n            str[index2] = `{${partsForObj(input2)}}`;\n          } else {\n            error = new Error(\"Cannot encode object with prototype\");\n          }\n        }\n        break;\n      }\n      default: {\n        const isArray = Array.isArray(input2);\n        let pluginHandled = false;\n        if (!isArray && plugins) {\n          for (const plugin of plugins) {\n            const pluginResult = plugin(input2);\n            if (Array.isArray(pluginResult)) {\n              pluginHandled = true;\n              const [pluginIdentifier, ...rest] = pluginResult;\n              str[index2] = `[${JSON.stringify(pluginIdentifier)}`;\n              if (rest.length > 0) {\n                str[index2] += `,${rest.map((v) => flatten.call(this, v)).join(\",\")}`;\n              }\n              str[index2] += \"]\";\n              break;\n            }\n          }\n        }\n        if (!pluginHandled) {\n          error = new Error(\"Cannot encode function or unexpected type\");\n        }\n      }\n    }\n    if (error) {\n      let pluginHandled = false;\n      if (postPlugins) {\n        for (const plugin of postPlugins) {\n          const pluginResult = plugin(input2);\n          if (Array.isArray(pluginResult)) {\n            pluginHandled = true;\n            const [pluginIdentifier, ...rest] = pluginResult;\n            str[index2] = `[${JSON.stringify(pluginIdentifier)}`;\n            if (rest.length > 0) {\n              str[index2] += `,${rest.map((v) => flatten.call(this, v)).join(\",\")}`;\n            }\n            str[index2] += \"]\";\n            break;\n          }\n        }\n      }\n      if (!pluginHandled) {\n        throw error;\n      }\n    }\n  }\n}\nvar objectProtoNames = Object.getOwnPropertyNames(Object.prototype).sort().join(\"\\0\");\nfunction isPlainObject(thing) {\n  const proto = Object.getPrototypeOf(thing);\n  return proto === Object.prototype || proto === null || Object.getOwnPropertyNames(proto).sort().join(\"\\0\") === objectProtoNames;\n}\n\n// src/unflatten.ts\nvar globalObj = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : void 0;\nfunction unflatten(parsed) {\n  const { hydrated, values } = this;\n  if (typeof parsed === \"number\")\n    return hydrate.call(this, parsed);\n  if (!Array.isArray(parsed) || !parsed.length)\n    throw new SyntaxError();\n  const startIndex = values.length;\n  for (const value of parsed) {\n    values.push(value);\n  }\n  hydrated.length = values.length;\n  return hydrate.call(this, startIndex);\n}\nfunction hydrate(index) {\n  const { hydrated, values, deferred, plugins } = this;\n  let result;\n  const stack = [\n    [\n      index,\n      (v) => {\n        result = v;\n      }\n    ]\n  ];\n  let postRun = [];\n  while (stack.length > 0) {\n    const [index2, set] = stack.pop();\n    switch (index2) {\n      case UNDEFINED:\n        set(void 0);\n        continue;\n      case NULL:\n        set(null);\n        continue;\n      case NAN:\n        set(NaN);\n        continue;\n      case POSITIVE_INFINITY:\n        set(Infinity);\n        continue;\n      case NEGATIVE_INFINITY:\n        set(-Infinity);\n        continue;\n      case NEGATIVE_ZERO:\n        set(-0);\n        continue;\n    }\n    if (hydrated[index2]) {\n      set(hydrated[index2]);\n      continue;\n    }\n    const value = values[index2];\n    if (!value || typeof value !== \"object\") {\n      hydrated[index2] = value;\n      set(value);\n      continue;\n    }\n    if (Array.isArray(value)) {\n      if (typeof value[0] === \"string\") {\n        const [type, b, c] = value;\n        switch (type) {\n          case TYPE_DATE:\n            set(hydrated[index2] = new Date(b));\n            continue;\n          case TYPE_URL:\n            set(hydrated[index2] = new URL(b));\n            continue;\n          case TYPE_BIGINT:\n            set(hydrated[index2] = BigInt(b));\n            continue;\n          case TYPE_REGEXP:\n            set(hydrated[index2] = new RegExp(b, c));\n            continue;\n          case TYPE_SYMBOL:\n            set(hydrated[index2] = Symbol.for(b));\n            continue;\n          case TYPE_SET:\n            const newSet = /* @__PURE__ */ new Set();\n            hydrated[index2] = newSet;\n            for (let i = 1; i < value.length; i++)\n              stack.push([\n                value[i],\n                (v) => {\n                  newSet.add(v);\n                }\n              ]);\n            set(newSet);\n            continue;\n          case TYPE_MAP:\n            const map = /* @__PURE__ */ new Map();\n            hydrated[index2] = map;\n            for (let i = 1; i < value.length; i += 2) {\n              const r = [];\n              stack.push([\n                value[i + 1],\n                (v) => {\n                  r[1] = v;\n                }\n              ]);\n              stack.push([\n                value[i],\n                (k) => {\n                  r[0] = k;\n                }\n              ]);\n              postRun.push(() => {\n                map.set(r[0], r[1]);\n              });\n            }\n            set(map);\n            continue;\n          case TYPE_NULL_OBJECT:\n            const obj = /* @__PURE__ */ Object.create(null);\n            hydrated[index2] = obj;\n            for (const key of Object.keys(b).reverse()) {\n              const r = [];\n              stack.push([\n                b[key],\n                (v) => {\n                  r[1] = v;\n                }\n              ]);\n              stack.push([\n                Number(key.slice(1)),\n                (k) => {\n                  r[0] = k;\n                }\n              ]);\n              postRun.push(() => {\n                obj[r[0]] = r[1];\n              });\n            }\n            set(obj);\n            continue;\n          case TYPE_PROMISE:\n            if (hydrated[b]) {\n              set(hydrated[index2] = hydrated[b]);\n            } else {\n              const d = new Deferred();\n              deferred[b] = d;\n              set(hydrated[index2] = d.promise);\n            }\n            continue;\n          case TYPE_ERROR:\n            const [, message, errorType] = value;\n            let error = errorType && globalObj && globalObj[errorType] ? new globalObj[errorType](message) : new Error(message);\n            hydrated[index2] = error;\n            set(error);\n            continue;\n          case TYPE_PREVIOUS_RESOLVED:\n            set(hydrated[index2] = hydrated[b]);\n            continue;\n          default:\n            if (Array.isArray(plugins)) {\n              const r = [];\n              const vals = value.slice(1);\n              for (let i = 0; i < vals.length; i++) {\n                const v = vals[i];\n                stack.push([\n                  v,\n                  (v2) => {\n                    r[i] = v2;\n                  }\n                ]);\n              }\n              postRun.push(() => {\n                for (const plugin of plugins) {\n                  const result2 = plugin(value[0], ...r);\n                  if (result2) {\n                    set(hydrated[index2] = result2.value);\n                    return;\n                  }\n                }\n                throw new SyntaxError();\n              });\n              continue;\n            }\n            throw new SyntaxError();\n        }\n      } else {\n        const array = [];\n        hydrated[index2] = array;\n        for (let i = 0; i < value.length; i++) {\n          const n = value[i];\n          if (n !== HOLE) {\n            stack.push([\n              n,\n              (v) => {\n                array[i] = v;\n              }\n            ]);\n          }\n        }\n        set(array);\n        continue;\n      }\n    } else {\n      const object = {};\n      hydrated[index2] = object;\n      for (const key of Object.keys(value).reverse()) {\n        const r = [];\n        stack.push([\n          value[key],\n          (v) => {\n            r[1] = v;\n          }\n        ]);\n        stack.push([\n          Number(key.slice(1)),\n          (k) => {\n            r[0] = k;\n          }\n        ]);\n        postRun.push(() => {\n          object[r[0]] = r[1];\n        });\n      }\n      set(object);\n      continue;\n    }\n  }\n  while (postRun.length > 0) {\n    postRun.pop()();\n  }\n  return result;\n}\n\n// src/turbo-stream.ts\nasync function decode(readable, options) {\n  const { plugins } = options ?? {};\n  const done = new Deferred();\n  const reader = readable.pipeThrough(createLineSplittingTransform()).getReader();\n  const decoder = {\n    values: [],\n    hydrated: [],\n    deferred: {},\n    plugins\n  };\n  const decoded = await decodeInitial.call(decoder, reader);\n  let donePromise = done.promise;\n  if (decoded.done) {\n    done.resolve();\n  } else {\n    donePromise = decodeDeferred.call(decoder, reader).then(done.resolve).catch((reason) => {\n      for (const deferred of Object.values(decoder.deferred)) {\n        deferred.reject(reason);\n      }\n      done.reject(reason);\n    });\n  }\n  return {\n    done: donePromise.then(() => reader.closed),\n    value: decoded.value\n  };\n}\nasync function decodeInitial(reader) {\n  const read = await reader.read();\n  if (!read.value) {\n    throw new SyntaxError();\n  }\n  let line;\n  try {\n    line = JSON.parse(read.value);\n  } catch (reason) {\n    throw new SyntaxError();\n  }\n  return {\n    done: read.done,\n    value: unflatten.call(this, line)\n  };\n}\nasync function decodeDeferred(reader) {\n  let read = await reader.read();\n  while (!read.done) {\n    if (!read.value)\n      continue;\n    const line = read.value;\n    switch (line[0]) {\n      case TYPE_PROMISE: {\n        const colonIndex = line.indexOf(\":\");\n        const deferredId = Number(line.slice(1, colonIndex));\n        const deferred = this.deferred[deferredId];\n        if (!deferred) {\n          throw new Error(`Deferred ID ${deferredId} not found in stream`);\n        }\n        const lineData = line.slice(colonIndex + 1);\n        let jsonLine;\n        try {\n          jsonLine = JSON.parse(lineData);\n        } catch (reason) {\n          throw new SyntaxError();\n        }\n        const value = unflatten.call(this, jsonLine);\n        deferred.resolve(value);\n        break;\n      }\n      case TYPE_ERROR: {\n        const colonIndex = line.indexOf(\":\");\n        const deferredId = Number(line.slice(1, colonIndex));\n        const deferred = this.deferred[deferredId];\n        if (!deferred) {\n          throw new Error(`Deferred ID ${deferredId} not found in stream`);\n        }\n        const lineData = line.slice(colonIndex + 1);\n        let jsonLine;\n        try {\n          jsonLine = JSON.parse(lineData);\n        } catch (reason) {\n          throw new SyntaxError();\n        }\n        const value = unflatten.call(this, jsonLine);\n        deferred.reject(value);\n        break;\n      }\n      default:\n        throw new SyntaxError();\n    }\n    read = await reader.read();\n  }\n}\nfunction encode(input, options) {\n  const { plugins, postPlugins, signal } = options ?? {};\n  const encoder = {\n    deferred: {},\n    index: 0,\n    indices: /* @__PURE__ */ new Map(),\n    stringified: [],\n    plugins,\n    postPlugins,\n    signal\n  };\n  const textEncoder = new TextEncoder();\n  let lastSentIndex = 0;\n  const readable = new ReadableStream({\n    async start(controller) {\n      const id = flatten.call(encoder, input);\n      if (Array.isArray(id)) {\n        throw new Error(\"This should never happen\");\n      }\n      if (id < 0) {\n        controller.enqueue(textEncoder.encode(`${id}\n`));\n      } else {\n        controller.enqueue(\n          textEncoder.encode(`[${encoder.stringified.join(\",\")}]\n`)\n        );\n        lastSentIndex = encoder.stringified.length - 1;\n      }\n      const seenPromises = /* @__PURE__ */ new WeakSet();\n      while (Object.keys(encoder.deferred).length > 0) {\n        for (const [deferredId, deferred] of Object.entries(encoder.deferred)) {\n          if (seenPromises.has(deferred))\n            continue;\n          seenPromises.add(\n            encoder.deferred[Number(deferredId)] = raceSignal(\n              deferred,\n              encoder.signal\n            ).then(\n              (resolved) => {\n                const id2 = flatten.call(encoder, resolved);\n                if (Array.isArray(id2)) {\n                  controller.enqueue(\n                    textEncoder.encode(\n                      `${TYPE_PROMISE}${deferredId}:[[\"${TYPE_PREVIOUS_RESOLVED}\",${id2[0]}]]\n`\n                    )\n                  );\n                  encoder.index++;\n                  lastSentIndex++;\n                } else if (id2 < 0) {\n                  controller.enqueue(\n                    textEncoder.encode(`${TYPE_PROMISE}${deferredId}:${id2}\n`)\n                  );\n                } else {\n                  const values = encoder.stringified.slice(lastSentIndex + 1).join(\",\");\n                  controller.enqueue(\n                    textEncoder.encode(\n                      `${TYPE_PROMISE}${deferredId}:[${values}]\n`\n                    )\n                  );\n                  lastSentIndex = encoder.stringified.length - 1;\n                }\n              },\n              (reason) => {\n                if (!reason || typeof reason !== \"object\" || !(reason instanceof Error)) {\n                  reason = new Error(\"An unknown error occurred\");\n                }\n                const id2 = flatten.call(encoder, reason);\n                if (Array.isArray(id2)) {\n                  controller.enqueue(\n                    textEncoder.encode(\n                      `${TYPE_ERROR}${deferredId}:[[\"${TYPE_PREVIOUS_RESOLVED}\",${id2[0]}]]\n`\n                    )\n                  );\n                  encoder.index++;\n                  lastSentIndex++;\n                } else if (id2 < 0) {\n                  controller.enqueue(\n                    textEncoder.encode(`${TYPE_ERROR}${deferredId}:${id2}\n`)\n                  );\n                } else {\n                  const values = encoder.stringified.slice(lastSentIndex + 1).join(\",\");\n                  controller.enqueue(\n                    textEncoder.encode(\n                      `${TYPE_ERROR}${deferredId}:[${values}]\n`\n                    )\n                  );\n                  lastSentIndex = encoder.stringified.length - 1;\n                }\n              }\n            ).finally(() => {\n              delete encoder.deferred[Number(deferredId)];\n            })\n          );\n        }\n        await Promise.race(Object.values(encoder.deferred));\n      }\n      await Promise.all(Object.values(encoder.deferred));\n      controller.close();\n    }\n  });\n  return readable;\n}\nfunction raceSignal(promise, signal) {\n  if (!signal)\n    return promise;\n  if (signal.aborted)\n    return Promise.reject(signal.reason || new Error(\"Signal was aborted.\"));\n  const abort = new Promise((resolve, reject) => {\n    signal.addEventListener(\"abort\", (event) => {\n      reject(signal.reason || new Error(\"Signal was aborted.\"));\n    });\n    promise.then(resolve).catch(reject);\n  });\n  abort.catch(() => {\n  });\n  return Promise.race([abort, promise]);\n}\nexport {\n  decode,\n  encode\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}